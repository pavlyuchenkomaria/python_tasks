Функция всегда возвращает значение,даже если нет return - в этом случае она возвращает None.

В интерпретаторе существует стек вызовов, в нем лежат стек-фреймы. Стек-фрейм содержит необходимую
информацию о вызове. При каждом вызове функции интерпретатор сначала вычисляет аргументы функции,
затем кладет стек-фрейм на стек вызовов, только после этого начинает выполнение самой функции.
После исполнения функции и выхода из нее стек-фрейм удаляется со стека.


Область видимости.

Разрешение имен идет в таком порядке (LEGB):
local - локальная область видимости, например, тело функции,
enclosing blocks - объемлющие блоки, например, внешняя функция для данной / тело скрипта,
global - глобальная таблица имен, куда попадают все переменные (объявленное или импортированное),
builtin - встроенные функции и переменные.

Если мы добавляем слово nonlocal внутри функции,
    nonlocal v # указываем, что v - это переменная из окружающей функции
    v = 10 # v поменялась для всей внешней функции
то теперь, если мы хотим обратиться к переменной v или ее изменить, нужно найти ее
в объемлющей области, и работать именно с ней.
Обычно nonlocal применяется во вложенных функциях, когда надо прикрепить идентификатор
за переменной или параметром окружающей внешней функции.

Если мы хотим изменить в локальной функции глобальную переменную, а не определить
локальную, то необходимо использовать ключевое слово global.
    global v # указываем, что v - это global переменная
    v = 10 # v поменялась везде


Аргументы функций.

Аргументы можно передавать как позициональные, можно именовать, но именованные аргументы должны
идти после позициональных. Теперь про *args, **kwargs:
    def f(*args):
        print(args) # tuple: (1,2,3,4)
        print(*args) # 1 2 3 4
        print(sum(args)) # 10
        print(sum(*args)) # error: sum() takes at most 2 arguments (4 given)
        return args
    a,b,c,d = f(1,2,3,4)
    print(a) # 1
args - обычный tuple, *args - элементы tuple
можно было бы написать def f(*any_possible_name_for_tuple).
def f(a, b, *args) - минимум 2 аргумента надо передать, они сами по себе

kwargs - словарь, который собирает только именнованные аргументы
    def f(**kwargs):
        print(kwargs) # {'a': 5, 'b': 1, 'c': 3}
        print(**kwargs) # error: 'a' is an invalid keyword argument for print()
    f(a=5, b=1, c='a')

Можно собирать их вместе:
способ 1:
    def f(*args, **kwargs):
        print(args, kwargs)

    f(1, 2, 3, c = 10, d = 20) # (1, 2, 3) {'c': 10, 'd': 20}

Либо распаковывать контейнеры при вызове функций.
способ 2:
    a = (1, 2, 3)
    b = {'c': 10, 'd': 20}
    f(*a, **b) # (1, 2, 3) {'c': 10, 'd': 20}

* - позициональные перечислены, далее именованные
/ - обязательные позициональные перечислены
    def f(a, b, /, c, d, *, e, f):
        print(a, b, c, d, e, f)
    # валидный вызов
    f(10, 20, 30, d=40, e=50, f=60)
    f(10, b=20, c=30, d=40, e=50, f=60) # b cannot be a keyword argument
    f(10, 20, 30, 40, 50, f=60) # e must be a keyword argument